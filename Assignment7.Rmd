---
title: "Assignment7"
geometry: paperheight=9in,paperwidth=12in,margin=1in
output: html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r eval=FALSE}
rm(list=ls())
```


<!-- # Libraries and other setup -->
```{r results="hide", message=FALSE}
# library(broom)
# library(data.table)
library(e1071)
library(kableExtra)
# library(gdata)
library(ggpubr)
# library(grid)
# library(gridExtra)
# library(gtable)
library(gridGraphics)
# library(magrittr)`
library(readr)
library(readxl)
library(reshape2)
library(tidyverse)

# setwd("D:/Documents/MGT 6090/Assignment 7")
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
```


<!-- # Saved env variables -->
```{r eval=FALSE}
# contains compustat and crsp_msf data
load("base.RData")
# contains calculated market variables
load("market_vars.RData")
# contains calculated market variables, portfolios, and plots
load("market_vars_done.RData")
# everything loaded in
load("all.RData")
```

<!-- # For running final program -->
```{r}
load("all.RData")
```

```{r eval=FALSE}
# keep(, sure=TRUE)
```

```{r eval=FALSE}
save.image(file="all.RData")
```


<!-- # Non data-dependent variables and functions -->
```{r eval=FALSE}
stat_fns <- list(
  volatility = ~sd(., na.rm = TRUE),
  skewness = ~skewness(., na.rm = TRUE),
  kurtosis = ~kurtosis(., na.rm = TRUE))

# Start and end date of desired data range for filtering
crsp_start_date <- as.Date("1969/01/01")
funda_start_date <- as.Date("1965/01/01")
end_date <- as.Date("2018/12/31")

# year is a vector of years
get_years_df <- function(year) {
  data.frame(year)
}

# Filter out financial firms and regulated utilities as is standard practice
filter_sich <- function(df) {
  df %>%
    filter((!between(SICH, 6000, 6999) & !between(SICH, 4900, 4999)) | is.na(SICH))
}

# Filter out firms involved in major mergers
filter_compustat <- function(df) {
  df %>%
    filter(COMPST != "AB" | is.na(COMPST))
}

# Filter to get rows with relevant SCF codes
filter_SCF <- function(df) {
  df %>%
    filter((SCF >= 1 & SCF <= 3) | SCF ==  7)
}

```


<!-- # Import and filter CRSP monthly data and rf data  -->
```{r eval=FALSE}
crsp_msf_cols <- cols_only(
  DATE = col_date(),
  CUSIP = col_character(),
  RET = col_double(),
  VWRETD = col_double(),
  PRC = col_double(),
  SHROUT = col_double())

# Import crsp_msf csv data
crsp <- read_csv("crsp_msf.csv", col_types = crsp_msf_cols)

# Filter to relevant dates
crsp <- crsp %>%
  filter(DATE >= crsp_start_date & DATE <= end_date) 

# Filter out values without market cap or return info
crsp <- crsp %>%
  filter(!is.na(RET)) %>%
  filter(!is.na(PRC)) %>%
  filter(!is.na(SHROUT))

# add month_year column, used for joins and rf rates
# we add 1 to the year to lag our data, eg. our 1969 data is now labeled as 1970, 
# so Jan 1, 1970 values are actually calculated using 1969 data
crsp <- crsp %>%
  mutate(month_year = as.numeric(format(DATE, "%Y%m"))) %>%
  mutate(year = 1 + as.numeric(format(DATE, "%Y")))

# import fama-french 3 factors
rf <- read_csv("F-F_Research_Data_Factors.csv", skip = 4, n_max = 1129, col_names = c("month_year", "Mkt-RF", "SMB", "HML", "RF"), col_types = list(col_double(), col_double(), col_double(), col_double(), col_double())) %>%
  select(month_year, RF, SMB, HML)

# join fama-french 3 factors
crsp <- crsp %>%
  left_join(rf, by = "month_year")

# import carhart momentum factor
mom <- read_csv("F-F_Momentum_Factor.csv", skip = 14, n_max = 1124, col_names = c("month_year", "MOM"), col_types = list(col_double(), col_double())) %>%
  select(month_year, MOM)

# join carhart momentum factor
crsp <- crsp %>%
  left_join(mom, by = "month_year")

# calculate excess return for individual stocks and market
crsp <- crsp %>%
  mutate(stock_excess = RET - RF/100) %>%
  mutate(mkt_excess = VWRETD - RF/100)

# save.image(file="base.RData")

```


<!-- # Generate VWRETD Returns -->
```{r eval=FALSE}
market_returns <- crsp %>%
  # get market returns and market excess for each month_year
  group_by(year,month_year) %>%
  summarise(month_mkt_ret = median(VWRETD), month_mkt_excess = median(mkt_excess), .groups = "drop") %>%
  # calculate compound market return and market excess for each year
  group_by(year) %>%
  arrange(month_year) %>%
  mutate(compound_mkt_ret = cumprod(1 + month_mkt_ret)) %>%
  mutate(compound_mkt_excess = cumprod(1 + month_mkt_excess)) %>%
  summarise(yearly_mkt_return = tail(compound_mkt_ret, n = 1), yearly_mkt_excess = tail(compound_mkt_excess, n = 1), .groups = "drop") %>%
  # calculate overall compounded market return and market excess
  arrange(year) %>%
  mutate(market_return = cumprod(yearly_mkt_return)) %>%
  mutate(market_excess = cumprod(yearly_mkt_excess))

market_returns_1970_2000 <- crsp %>%
  filter(year >= 1970 & year <= 2000) %>%
  # get market returns and market excess for each month_year
  group_by(year,month_year) %>%
  summarise(month_mkt_ret = median(VWRETD), month_mkt_excess = median(mkt_excess), .groups = "drop") %>%
  # calculate compound market return and market excess for each year
  group_by(year) %>%
  arrange(month_year) %>%
  mutate(compound_mkt_ret = cumprod(1 + month_mkt_ret)) %>%
  mutate(compound_mkt_excess = cumprod(1 + month_mkt_excess)) %>%
  summarise(yearly_mkt_return = tail(compound_mkt_ret, n = 1), yearly_mkt_excess = tail(compound_mkt_excess, n = 1), .groups = "drop") %>%
  # calculate overall compounded market return and market excess
  arrange(year) %>%
  mutate(market_return = cumprod(yearly_mkt_return)) %>%
  mutate(market_excess = cumprod(yearly_mkt_excess))

market_returns_2001_2019 <- crsp %>%
  filter(year >= 2001 & year <= 2019) %>%
  # get market returns and market excess for each month_year
  group_by(year,month_year) %>%
  summarise(month_mkt_ret = median(VWRETD), month_mkt_excess = median(mkt_excess), .groups = "drop") %>%
  # calculate compound market return and market excess for each year
  group_by(year) %>%
  arrange(month_year) %>%
  mutate(compound_mkt_ret = cumprod(1 + month_mkt_ret)) %>%
  mutate(compound_mkt_excess = cumprod(1 + month_mkt_excess)) %>%
  summarise(yearly_mkt_return = tail(compound_mkt_ret, n = 1), yearly_mkt_excess = tail(compound_mkt_excess, n = 1), .groups = "drop") %>%
  # calculate overall compounded market return and market excess
  arrange(year) %>%
  mutate(market_return = cumprod(yearly_mkt_return)) %>%
  mutate(market_excess = cumprod(yearly_mkt_excess))

# save.image(file="base.RData")

```


<!-- # Calculate crsp market variables -->
```{r eval=FALSE}
# Calculate stock market caps
crsp <- crsp %>%
  mutate(mkt_cap = abs(PRC) * SHROUT)

get_capm_beta <- function(stock_excess, mkt_excess) {
  n <- length(mkt_excess)
  lin_reg <- lm.fit(cbind(rep(1, n), mkt_excess), stock_excess)
  return(lin_reg$coefficients[["mkt_excess"]])
}

get_total_vol <- function(stock_ret) {
  return(sd(stock_ret) * 100 * sqrt(12))
}

get_total_vol_zero_avg <- function(stock_ret) {
  n <- length(stock_ret)
  return(sqrt(sum(stock_ret^2) / n) * 100 * sqrt(12))
}

get_idio_vol_capm <- function(stock_excess, mkt_excess) {
  n <- length(mkt_excess)
  if (n - 2 <= 0) {
    return(NA)
  }
  lin_reg <- lm.fit(cbind(rep(1, n), mkt_excess), stock_excess)
  rse <- sqrt(sum(lin_reg$residuals^2) / (n - 2))
  return(100 * rse * sqrt(12))
}

get_idio_vol_ff3 <- function(stock_excess, mkt_excess, smb, hml) {
  n <- length(mkt_excess)
  if (n - 4 <= 0) {
    return(NA)
  }  
  lin_reg <- lm.fit(cbind(rep(1, n), mkt_excess, smb, hml), stock_excess)
  rse <- sqrt(sum(lin_reg$residuals^2) / (n - 4))
  return(100 * rse * sqrt(12))
}

get_idio_vol_ff3_mom <- function(stock_excess, mkt_excess, smb, hml, mom) {
  n <- length(mkt_excess)
  if (n - 5 <= 0) {
    return(NA)
  }
  lin_reg <- lm.fit(cbind(rep(1, n), mkt_excess, smb, hml, mom), stock_excess)
  rse <- sqrt(sum(lin_reg$residuals^2) / (n - 5))
  return(100 * rse * sqrt(12))
}

# Calculate market variables, 
# average market cap and average stock price will be used for future filtering
market_vars <- crsp %>%
  group_by(CUSIP, year) %>%
  arrange(DATE) %>%
  mutate(compound_ret = cumprod(1 + RET)) %>%
  mutate(compound_excess = cumprod(1 + stock_excess)) %>%
  summarise(max_mkt_cap = max(mkt_cap), 
            max_prc = max(abs(PRC)), 
            capm_beta = get_capm_beta(stock_excess, mkt_excess),
            total_vol = get_total_vol(RET),
            total_vol_zero_avg = get_total_vol_zero_avg(RET),
            idio_vol_capm = get_idio_vol_capm(stock_excess, mkt_excess), 
            idio_vol_ff3 = get_idio_vol_ff3(stock_excess, mkt_excess, SMB, HML), 
            idio_vol_ff3_mom = get_idio_vol_ff3_mom(stock_excess, mkt_excess, SMB, HML, MOM), 
            yearly_ret = tail(compound_ret, n = 1), 
            yearly_excess = tail(compound_excess, n = 1), .groups = "drop")

# filter to stocks/years with average yearly market cap of at least 100 million
# and stock price at least 5
market_vars <- market_vars %>%
  filter(max_mkt_cap >= 100000) %>%
  filter(max_prc >= 5)

# save.image(file="market_vars.RData")

```


<!-- # Import and filter COMPUSTAT data -->
```{r eval=FALSE}
funda_cols <- cols_only(
  DATADATE = col_date(),
  FYEAR = col_integer(),
  SCF = col_integer(),
  SICH = col_integer(),
  COMPST = col_character(),
  # For joining COMPUSTAT and CRSP
  CUSIP = col_character(),
  # For calculating Book Value
  AT = col_double(),
  LT = col_double(),
  # Cash Flow
  CH = col_double(),
  # Revenue
  REVT = col_double(),
  # Sales
  SALE = col_double(),
  # Dividends
  DV = col_double(),
  # For calculating Investments
  SCF = col_integer(), 
  CAPX = col_double(),
  IVCH = col_double(),
  AQC = col_double(),
  FUSEO = col_double(),
  SPPE = col_double(),
  SIV = col_double(),
  IVSTCH = col_double(),
  IVACO = col_double(),
  # For calculating Profitability
  NI = col_double(),
  # For calculating Altman Z-score
  ACT = col_double(),
  LCT = col_double(),
  RE = col_double(),
  NI = col_double(),
  XINT = col_double(),
  TXT = col_double(),
  CSHO = col_double(),
  PRCC_F = col_double(),
  # For calculating Ohlson O-score
  FFO = col_double()
)

# import compustat data and do some basic filtering
funda <- read_csv("funda.csv", col_types = funda_cols)

# make compustat CUSIP column match crsp data CUSIP
funda <- funda %>%
  mutate(CUSIP = substr(CUSIP, 1, 8))

# Filter to data between 1/1/1965 and 12/31/2019
funda <- funda %>%
  filter(DATADATE >= funda_start_date & DATADATE <= end_date)

# filters following standard practice
funda <- funda %>%
  filter_compustat() %>%
  filter_SCF() %>%
  filter_sich() %>%
  select(-c("COMPST", "SICH"))

# lag the fiscal year column
funda <- funda %>%
  filter(!is.na(FYEAR)) %>%
  mutate(year = 1 + FYEAR) %>%
  select(-c("DATADATE", "FYEAR"))

# replace NA values with 0
funda <- funda %>%
  mutate_all(~replace(., is.na(.), 0))

# import GNP data
gnp <- read_csv("GNP.csv", skip = 0, n_max = 294, col_types = list(col_date(), col_double()))
gnp <- gnp %>%
  filter(as.numeric(format(DATE, "%m")) == 10) %>%
  mutate(year = 1 + as.numeric(format(DATE, "%Y"))) %>%
  filter(year >= 1970 & year <= 2019) %>%
  select(year, GNP)

# join with other data
funda <- funda %>%
  left_join(gnp, by = "year")


```


<!-- # Calculate compustat fundamental variables -->
```{r eval=FALSE}
# calculate altman_z score given columns
get_altman_z <- function(ACT, LCT, AT, RE, NI, XINT, TXT, CSHO, PRCC_F, LT, SALE) {
  x1 <- (ACT - LCT) / AT
  x2 <-  RE / AT
  x3 <- (NI + XINT + TXT) / AT
  x4 <- CSHO * PRCC_F / LT
  x5 <- SALE / AT
  return(1.2*x1 + 1.4*x2 + 3.3*x3 + 0.6*x4 + x5)
}

# calculate ohlson-o score, returns NA if there is no t-1 net income
get_ohlson_o <- function(AT, LT, GNP, ACT, LCT, NI, NI_lag, FFO) {
  f1 <- -0.407 * log(AT / GNP)
  f2 <- 6.03 * LT / AT
  f3 <- -1.43 * (ACT - LCT) / AT
  f4 <- 0.0757 * LCT / ACT
  f5 <- -1.72 * ifelse(LT > AT, 1, 0)
  f6 <- -2.37 * NI / AT
  f7 <- -1.83 * FFO / LT
  f8 <- case_when(
    is.na(NI_lag) == TRUE ~ NA_real_,
    NI < 0 & NI_lag < 0 ~ 0.285,
    TRUE ~ 0)
  f9 <- -0.521 * (NI - NI_lag) / (abs(NI) + abs(NI_lag))
  return(-1.32 + f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9)
}

# Calculate fundamental variables
funda_vars <- funda %>%
  # these values being 0 causes issues with altman-z and ohlson-o calculations
  filter(AT != 0) %>%
  filter(LT != 0) %>%
  filter(ACT != 0) %>%
  mutate(book_value = AT - LT) %>%
  mutate(investments = ifelse(SCF == 7, CAPX+IVCH+AQC-SPPE-SIV-IVSTCH-IVACO, CAPX+IVCH+AQC+FUSEO-SPPE-SIV)) %>%
  mutate(profitability = NI / AT) %>%
  mutate(asset_turnover = REVT / AT) %>%
  mutate(altman_z = get_altman_z(ACT, LCT, AT, RE, NI, XINT, TXT, CSHO, PRCC_F, LT, SALE)) %>%
  group_by(CUSIP) %>%
  arrange(year) %>%
  # generate lagged net income column for ohlson-o score calcs
  mutate(NI_lag = lag(NI, n = 1)) %>%
  ungroup() %>%
  mutate(ohlson_o = get_ohlson_o(AT, LT, GNP, ACT, LCT, NI, NI_lag, FFO))


# calculate trailing five year averages
get_trailing_5yr_avg <- function(df, var_col, new_col) {
  df %>%
    group_by(CUSIP) %>%
    arrange(year) %>%
    # get lagged data and corresponding year
    mutate(lag1 = lag(!!as.name(var_col), n = 1)) %>%
    mutate(lag2 = lag(!!as.name(var_col), n = 2)) %>%
    mutate(lag3 = lag(!!as.name(var_col), n = 3)) %>%
    mutate(lag4 = lag(!!as.name(var_col), n = 4)) %>%
    mutate(lagyear1 = lag(year, n = 1)) %>%
    mutate(lagyear2 = lag(year, n = 2)) %>%
    mutate(lagyear3 = lag(year, n = 3)) %>%
    mutate(lagyear4 = lag(year, n = 4)) %>%
    ungroup %>%
    # verify that lagged data is within 5 years inclusive (accounting for skipped years)
    mutate(lag1 = ifelse(year - lagyear1 > 4, NA, lag1)) %>%
    mutate(lag2 = ifelse(year - lagyear2 > 4, NA, lag2)) %>%
    mutate(lag3 = ifelse(year - lagyear3 > 4, NA, lag3)) %>%
    mutate(lag4 = ifelse(year - lagyear4 > 4, NA, lag4)) %>%
    # generate sum and count of non-NA data and calculate average
    mutate(sums = ifelse(is.na(!!as.name(var_col)) == TRUE, 0, !!as.name(var_col)) + ifelse(is.na(lag1) == TRUE, 0, lag1) + ifelse(is.na(lag2) == TRUE, 0, lag2) + ifelse(is.na(lag3) == TRUE, 0, lag3) + ifelse(is.na(lag4) == TRUE, 0, lag4)) %>%
    mutate(N = ifelse(is.na(!!as.name(var_col)) == TRUE, 0, 1) + ifelse(is.na(lag1) == TRUE, 0, 1) + ifelse(is.na(lag2) == TRUE, 0, 1) + ifelse(is.na(lag3) == TRUE, 0, 1) + ifelse(is.na(lag4) == TRUE, 0, 1)) %>%
    mutate(!!new_col := sums / N) %>%
    select(-c("lag1", "lag2", "lag3", "lag4", "lagyear1", "lagyear2", "lagyear3", "lagyear4", "sums", "N"))
}


# Calculate trailing 5-year averages for desired variables
funda_vars <- funda_vars %>%
  get_trailing_5yr_avg("CH", "cash_flow_trail_5yr_avg") %>%
  get_trailing_5yr_avg("REVT", "revenue_trail_5yr_avg") %>%
  get_trailing_5yr_avg("SALE", "sales_trail_5yr_avg") %>%
  get_trailing_5yr_avg("DV", "dividends_trail_5yr_avg") %>%
  get_trailing_5yr_avg("investments", "investments_trail_5yr_avg") %>%
  get_trailing_5yr_avg("profitability", "profitability_trail_5yr_avg") %>%
  select(year, CUSIP, book_value, cash_flow_trail_5yr_avg, revenue_trail_5yr_avg, sales_trail_5yr_avg, dividends_trail_5yr_avg, investments_trail_5yr_avg, profitability_trail_5yr_avg, asset_turnover, altman_z, ohlson_o) %>%
  arrange(CUSIP, year)


# get the previously calculated list of companies and years with yearly returns and excess returns
# that also match the market cap and price minimum criteria and join this to our new vars
funda_vars <- market_vars %>%
  select(year, CUSIP, yearly_ret, yearly_excess) %>%
  right_join(funda_vars, by = c("year", "CUSIP")) %>%
  filter(!is.na(yearly_ret) & !is.na(yearly_excess))

```


<!-- # Generate variable weighted portfolios -->
```{r eval=FALSE}
# var_df is the dataframe containing variable values for each CUSIP for each year
# var_names is a character vector of variable names to iterate over
# years is a vector of years the data should be over
# compound_ret is a boolean, true if compounded, false if we just want the yearly returns
get_variables_portfolio <- function(var_df, var_names, years, compound_ret) {
  var_portfolio <- get_years_df(years)
  # use each variable to calculate a portfolio of the variable-weighted returns by year
  for (var_name in var_names) {
    var_col_name <- paste(var_name, "portfolio", sep = "_")
    if (compound_ret == TRUE) {
      var_portfolio <- var_df %>%
        filter(year >= min(years) & year <= max(years)) %>%
        filter(!is.na(!!as.name(var_name))) %>%
        group_by(year) %>%
        summarise(weighted_var_yearly_ret = sum(yearly_ret * abs(!!as.name(var_name)) / sum(abs(!!as.name(var_name)))), .groups = "drop") %>%
        arrange(year) %>%
        mutate(!!var_col_name := cumprod(weighted_var_yearly_ret)) %>%
        select(year, !!var_col_name) %>%
        left_join(var_portfolio, ., by = "year")      
    } else {
      var_portfolio <- var_df %>%
        filter(year >= min(years) & year <= max(years)) %>%
        filter(!is.na(!!as.name(var_name))) %>%
        group_by(year) %>%
        summarise(!!var_col_name := sum(yearly_ret * abs(!!as.name(var_name)) / sum(abs(!!as.name(var_name)))), .groups = "drop") %>%
        left_join(var_portfolio, ., by = "year")    
    }
  }
  return(var_portfolio)
}


# the same as above, but for excess returns
get_portfolio_excess <- function(var_df, var_names, years, compound_ret) {
  var_portfolio <- get_years_df(years)
  # use each variable to calculate a portfolio of the variable-weighted returns by year
  for (var_name in var_names) {
    var_col_name <- paste(var_name, "portfolio", sep = "_")
    if (compound_ret == TRUE) {
      var_portfolio <- var_df %>%
        filter(year >= min(years) & year <= max(years)) %>%
        filter(!is.na(!!as.name(var_name))) %>%
        group_by(year) %>%
        summarise(weighted_var_yearly_ret = sum(yearly_excess * abs(!!as.name(var_name)) / sum(abs(!!as.name(var_name)))), .groups = "drop") %>%
        arrange(year) %>%
        mutate(!!var_col_name := cumprod(weighted_var_yearly_ret)) %>%
        select(year, !!var_col_name) %>%
        left_join(var_portfolio, ., by = "year")      
    } else {
      var_portfolio <- var_df %>%
        filter(year >= min(years) & year <= max(years)) %>%
        filter(!is.na(!!as.name(var_name))) %>%
        group_by(year) %>%
        summarise(!!var_col_name := sum(yearly_excess * abs(!!as.name(var_name)) / sum(abs(!!as.name(var_name)))), .groups = "drop") %>%
        left_join(var_portfolio, ., by = "year")    
    }
  }
  return(var_portfolio)
}

# join portfolio with market return info and generate plot
# compound_ret is a boolean, true if compounded, false if we just want the yearly returns
plot_portfolio_with_market <- function(market_df, portfolio_df, years, compound_ret) {
  if (compound_ret == TRUE) {
    portfolio_plot <- market_df %>%
      filter(year >= min(years) & year <= max(years)) %>%
      select(year, market_return) %>%
      left_join(portfolio_df, by = "year") %>%
      melt(id = "year") %>%
      ggplot(aes(x = year, y = value, color = variable)) +
      ylab("Returns") +
      geom_line()
  } else {
    portfolio_plot <- market_df %>%
      filter(year >= min(years) & year <= max(years)) %>%
      select(year, yearly_mkt_return) %>%
      left_join(portfolio_df, by = "year") %>%
      melt(id = "year") %>%
      ggplot(aes(x = year, y = value, color = variable)) +
      ylab("Returns") +
      geom_line()
  }
  return(portfolio_plot)
}

# get vector of fundamental variable names to iterate over
funda_var_names <- funda_vars %>%
  select(-c("year", "CUSIP", "yearly_ret", "yearly_excess")) %>%
  colnames()

# calculate fundamental variable weighted portfolio returns
funda_var_port_1970_2019 <- get_variables_portfolio(funda_vars, funda_var_names, 1970:2019, TRUE)
funda_var_port_1970_2000 <- get_variables_portfolio(funda_vars, funda_var_names, 1970:2000, TRUE)
funda_var_port_2001_2019 <- get_variables_portfolio(funda_vars, funda_var_names, 2001:2019, TRUE)

# generate plots
# altman-z plotted separately because returns were significantly larger
funda_var_1970_2019_plot <- funda_var_port_1970_2019 %>%
  select(-altman_z_portfolio) %>%
  plot_portfolio_with_market(market_returns, ., 1970:2019, TRUE)

funda_var_1970_2000_plot <- funda_var_port_1970_2000 %>%
  select(-altman_z_portfolio) %>%
  plot_portfolio_with_market(market_returns_1970_2000, ., 1970:2000, TRUE)

funda_var_2001_2019_plot <- funda_var_port_2001_2019 %>%
  select(-altman_z_portfolio) %>%
  plot_portfolio_with_market(market_returns_2001_2019, ., 2001:2019, TRUE)

funda_altman_1970_2019_plot <- funda_var_port_1970_2019 %>%
  select(year, altman_z_portfolio) %>%
  plot_portfolio_with_market(market_returns, ., 1970:2019, TRUE)

funda_altman_1970_2000_plot <- funda_var_port_1970_2000 %>%
  select(year, altman_z_portfolio) %>%
  plot_portfolio_with_market(market_returns_1970_2000, ., 1970:2000, TRUE)

funda_altman_2001_2019_plot <- funda_var_port_2001_2019 %>%
  select(year, altman_z_portfolio) %>%
  plot_portfolio_with_market(market_returns_2001_2019, ., 2001:2019, TRUE)

# get weighted returns non-cumulative and plot
funda_port_1970_2019_yearly <- get_variables_portfolio(funda_vars, funda_var_names, 1970:2019, FALSE)
funda_1970_2019_plot2 <- plot_portfolio_with_market(market_returns, funda_port_1970_2019_yearly, 1970:2019, FALSE)

# get vector of market variables names to iterate over
market_var_names <- market_vars %>%
  select(-c("year", "CUSIP", "max_mkt_cap", "max_prc", "yearly_ret", "yearly_excess")) %>%
  colnames()

# calculate market variable weighted portfolio returns
market_var_port_1970_2019 <- get_variables_portfolio(market_vars, market_var_names, 1970:2019, TRUE)
market_var_port_1970_2000 <- get_variables_portfolio(market_vars, market_var_names, 1970:2000, TRUE)
market_var_port_2001_2019 <- get_variables_portfolio(market_vars, market_var_names, 2001:2019, TRUE)

# generate plots
market_var_1970_2019_plot <- plot_portfolio_with_market(market_returns, market_var_port_1970_2019, 1970:2019, TRUE)
market_var_1970_2000_plot <- plot_portfolio_with_market(market_returns_1970_2000, market_var_port_1970_2000, 1970:2000, TRUE)
market_var_2001_2019_plot <- plot_portfolio_with_market(market_returns_2001_2019, market_var_port_2001_2019, 2001:2019, TRUE)

# get weighted returns non-cumulative and plot
market_1970_2019_yearly <- get_variables_portfolio(market_vars, market_var_names, 1970:2019, FALSE)
market_1970_2019_plot2 <- plot_portfolio_with_market(market_returns, market_1970_2019_yearly, 1970:2019, FALSE)

# save.image(file="market_vars_done.RData")
```


<!-- # Compute descriptive stats for fundamental variables-->
```{r eval=FALSE}
# calculate volatility, skewness, and kurtosis for fundamental variable weighted portfolio returns
funda_stats <- funda_port_1970_2019_yearly %>%
  summarise_at(vars(-year), stat_fns) %>%
  gather(key, val) %>%
  separate(key, c("portfolio_returns", "temp"), sep = "(_volatility|_skewness|_kurtosis)", remove = FALSE) %>%
  mutate(descript_stat = str_remove(key, paste(portfolio_returns, "_", sep = ""))) %>%
  select(portfolio_returns, descript_stat, val) %>%
  group_by(portfolio_returns) %>%
  summarise(volatility = sum(ifelse(descript_stat == "volatility", val, 0)), 
            skewness = sum(ifelse(descript_stat == "skewness", val, 0)),
            kurtosis = sum(ifelse(descript_stat == "kurtosis", val, 0)), .groups = "drop")

# get excess returns and calculate sharpe ratio
funda_stats <- get_portfolio_excess(funda_vars, funda_var_names, 1970:2019, FALSE) %>%
  summarise(book_value_portfolio = mean(book_value_portfolio, na.rm = TRUE) / sd(book_value_portfolio, na.rm = TRUE),
            cash_flow_trail_5yr_avg_portfolio = mean(cash_flow_trail_5yr_avg_portfolio, na.rm = TRUE) / sd(cash_flow_trail_5yr_avg_portfolio, na.rm = TRUE),
            revenue_trail_5yr_avg_portfolio = mean(revenue_trail_5yr_avg_portfolio, na.rm = TRUE) / sd(revenue_trail_5yr_avg_portfolio, na.rm = TRUE),
            sales_trail_5yr_avg_portfolio = mean(sales_trail_5yr_avg_portfolio, na.rm = TRUE) / sd(sales_trail_5yr_avg_portfolio, na.rm = TRUE),
            dividends_trail_5yr_avg_portfolio = mean(dividends_trail_5yr_avg_portfolio, na.rm = TRUE) / sd(dividends_trail_5yr_avg_portfolio, na.rm = TRUE),
            investments_trail_5yr_avg_portfolio = mean(investments_trail_5yr_avg_portfolio, na.rm = TRUE) / sd(investments_trail_5yr_avg_portfolio, na.rm = TRUE),
            profitability_trail_5yr_avg_portfolio = mean(profitability_trail_5yr_avg_portfolio, na.rm = TRUE) / sd(profitability_trail_5yr_avg_portfolio, na.rm = TRUE),
            asset_turnover_portfolio = mean(asset_turnover_portfolio, na.rm = TRUE) / sd(asset_turnover_portfolio, na.rm = TRUE),
            altman_z_portfolio = mean(altman_z_portfolio, na.rm = TRUE) / sd(altman_z_portfolio, na.rm = TRUE),
            ohlson_o_portfolio = mean(ohlson_o_portfolio, na.rm = TRUE) / sd(ohlson_o_portfolio, na.rm = TRUE)) %>%
  t() %>%
  data.frame() %>%
  rownames_to_column("portfolio_returns") %>%
  rename(., sharpe_ratio = ".") %>%
  left_join(funda_stats, by = "portfolio_returns")

# calculate information ratio for each portfolio
get_information_ratio <- function(ret_col, mkt_col) {
  return(mean(ret_col - mkt_col, na.rm = TRUE) / sd(ret_col - mkt_col, na.rm = TRUE))
}

funda_stats <- market_returns %>%
  select(year, yearly_mkt_return) %>%
  right_join(funda_port_1970_2019_yearly, by = "year") %>%
  summarise(book_value_portfolio = get_information_ratio(book_value_portfolio, yearly_mkt_return),
            cash_flow_trail_5yr_avg_portfolio = get_information_ratio(cash_flow_trail_5yr_avg_portfolio, yearly_mkt_return),
            revenue_trail_5yr_avg_portfolio = get_information_ratio(revenue_trail_5yr_avg_portfolio, yearly_mkt_return),
            sales_trail_5yr_avg_portfolio = get_information_ratio(sales_trail_5yr_avg_portfolio, yearly_mkt_return),
            dividends_trail_5yr_avg_portfolio = get_information_ratio(dividends_trail_5yr_avg_portfolio, yearly_mkt_return),
            investments_trail_5yr_avg_portfolio = get_information_ratio(investments_trail_5yr_avg_portfolio, yearly_mkt_return),
            profitability_trail_5yr_avg_portfolio = get_information_ratio(profitability_trail_5yr_avg_portfolio, yearly_mkt_return),
            asset_turnover_portfolio = get_information_ratio(asset_turnover_portfolio, yearly_mkt_return),
            altman_z_portfolio = get_information_ratio(altman_z_portfolio, yearly_mkt_return),
            ohlson_o_portfolio = get_information_ratio(ohlson_o_portfolio, yearly_mkt_return)) %>%
  t() %>%
  data.frame() %>%
  rownames_to_column("portfolio_returns") %>%
  rename(., information_ratio = ".") %>%
  left_join(funda_stats, by = "portfolio_returns")

```


<!-- # Compute descriptive stats for market variables-->
```{r eval=FALSE}
# calculate volatility, skewness, and kurtosis for market variable weighted portfolio returns
market_stats <- market_1970_2019_yearly %>%
  summarise_at(vars(-year), stat_fns) %>%
  gather(key, val) %>%
  separate(key, c("portfolio_returns", "temp"), sep = "(_volatility|_skewness|_kurtosis)", remove = FALSE) %>%
  mutate(descript_stat = str_remove(key, paste(portfolio_returns, "_", sep = ""))) %>%
  select(portfolio_returns, descript_stat, val) %>%
  group_by(portfolio_returns) %>%
  summarise(volatility = sum(ifelse(descript_stat == "volatility", val, 0)), 
            skewness = sum(ifelse(descript_stat == "skewness", val, 0)),
            kurtosis = sum(ifelse(descript_stat == "kurtosis", val, 0)), .groups = "drop")


# get excess returns and calculate sharpe ratio
market_stats <- get_portfolio_excess(market_vars, market_var_names, 1970:2019, FALSE) %>%
  summarise(capm_beta_portfolio = mean(capm_beta_portfolio, na.rm = TRUE) / sd(capm_beta_portfolio, na.rm = TRUE),
            total_vol_portfolio = mean(total_vol_portfolio, na.rm = TRUE) / sd(total_vol_portfolio, na.rm = TRUE),
            total_vol_zero_avg_portfolio = mean(total_vol_zero_avg_portfolio, na.rm = TRUE) / sd(total_vol_zero_avg_portfolio, na.rm = TRUE),
            idio_vol_capm_portfolio = mean(idio_vol_capm_portfolio, na.rm = TRUE) / sd(idio_vol_capm_portfolio, na.rm = TRUE),
            idio_vol_ff3_portfolio = mean(idio_vol_ff3_portfolio, na.rm = TRUE) / sd(idio_vol_ff3_portfolio, na.rm = TRUE),
            idio_vol_ff3_mom_portfolio = mean(idio_vol_ff3_mom_portfolio, na.rm = TRUE) / sd(idio_vol_ff3_mom_portfolio, na.rm = TRUE)) %>%
  t() %>%
  data.frame() %>%
  rownames_to_column("portfolio_returns") %>%
  rename(., sharpe_ratio = ".") %>%
  left_join(market_stats, by = "portfolio_returns")

# calculate information ratio for each portfolio
market_stats <- market_returns %>%
  select(year, yearly_mkt_return) %>%
  right_join(market_1970_2019_yearly, by = "year") %>%
  summarise(capm_beta_portfolio = get_information_ratio(capm_beta_portfolio, yearly_mkt_return),
            total_vol_portfolio = get_information_ratio(total_vol_portfolio, yearly_mkt_return),
            total_vol_zero_avg_portfolio = get_information_ratio(total_vol_zero_avg_portfolio, yearly_mkt_return),
            idio_vol_capm_portfolio = get_information_ratio(idio_vol_capm_portfolio, yearly_mkt_return),
            idio_vol_ff3_portfolio = get_information_ratio(idio_vol_ff3_portfolio, yearly_mkt_return),
            idio_vol_ff3_mom_portfolio = get_information_ratio(idio_vol_ff3_mom_portfolio, yearly_mkt_return)) %>%
  t() %>%
  data.frame() %>%
  rownames_to_column("portfolio_returns") %>%
  rename(., information_ratio = ".") %>%
  left_join(market_stats, by = "portfolio_returns")

```


<!-- # Compare excess returns to MKT, SMB, and HML -->
```{r eval=FALSE}
rf_other <- read_csv("F-F_Research_Data_Factors.csv", skip = 1136, n_max = 93, col_names = c("year", "Mkt-RF", "SMB", "HML", "RF"), col_types = list(col_double(), col_double(), col_double(), col_double(), col_double())) %>%
  rename(MKT = `Mkt-RF`) %>%
  select(year, MKT, SMB, HML)

rf_other <- rf_other %>%
  filter(year >= 1970 & year <= 2019) %>%
  arrange(year)

rf_other_compound <- rf_other %>%
  mutate(MKT = cumprod(1 + MKT/100)) %>%
  mutate(SMB = cumprod(1 + SMB/100)) %>%
  mutate(HML = cumprod(1 + HML/100))

rf_other_yearly <- rf_other %>%
  mutate(MKT = 1+ MKT/100) %>%
  mutate(SMB = 1 + SMB/100) %>%
  mutate(HML = 1 + HML/100)

# get compounded excess portfolio returns for fundamental variables and plot with MKT, SMB, HML
funda_excess_ports_compound <- get_portfolio_excess(funda_vars, funda_var_names, 1970:2019, TRUE) %>%
  left_join(rf_other_compound, by = "year")

funda_excess_ports_compound_plot <- funda_excess_ports_compound %>%
  select(-altman_z_portfolio) %>%
  melt(id = "year") %>%
  ggplot(aes(x = year, y = value, color = variable)) +
  ylab("Returns") +
  geom_line()

# plot altman
funda_compound_altman <- funda_excess_ports_compound %>%
  select(year, altman_z_portfolio, MKT, SMB, HML) %>%
  melt(id = "year") %>%
  ggplot(aes(x = year, y = value, color = variable)) +
  ylab("Returns") +
  geom_line()

# get yearly excess portfolio returns for fundamental variables and plot with MKT, SMB, HML
funda_excess_ports_yearly <- get_portfolio_excess(funda_vars, funda_var_names, 1970:2019, FALSE) %>%
  left_join(rf_other_yearly, by = "year")

funda_excess_ports_yearly_plot <- funda_excess_ports_yearly %>%
  melt(id = "year") %>%
  ggplot(aes(x = year, y = value, color = variable)) +
  ylab("Returns") +
  geom_line()

# repeat above process for market variables
market_excess_ports_compound <- get_portfolio_excess(market_vars, market_var_names, 1970:2019, TRUE) %>%
  left_join(rf_other_compound, by = "year")

market_excess_ports_compound_plot <- market_excess_ports_compound %>%
  melt(id = "year") %>%
  ggplot(aes(x = year, y = value, color = variable)) +
  ylab("Returns") +
  geom_line()

# get yearly excess portfolio returns for fundamental variables and plot with MKT, SMB, HML
market_excess_ports_yearly <- get_portfolio_excess(market_vars, market_var_names, 1970:2019, FALSE) %>%
  left_join(rf_other_yearly, by = "year")

market_excess_ports_yearly_plot <- market_excess_ports_yearly %>%
  melt(id = "year") %>%
  ggplot(aes(x = year, y = value, color = variable)) +
  ylab("Returns") +
  geom_line()

```





<!-- ############## PLOTS START HERE ############### -->


# Fundamental variable-weighted potfolio and VWRETD compounded returns
```{r fig.width=18, fig.height=9, warning=FALSE}
# for knitr output
ggarrange(funda_var_1970_2019_plot + theme(legend.position = "bottom"), 
          ggarrange(funda_var_1970_2000_plot + theme(legend.position = "bottom") + guides(color = guide_legend(nrow = 4)), 
                    funda_var_2001_2019_plot + theme(legend.position = "bottom") + guides(color = guide_legend(nrow = 4)), 
                    ncol = 2, nrow = 1), ncol = 1, nrow = 2)
```

### The Altman Z-score weighted portfolio was significantly different, so it is plotted separately
```{r fig.width=18, fig.height=9, warning=FALSE}
ggarrange(funda_altman_1970_2019_plot + theme(legend.position = "bottom"), 
          ggarrange(funda_altman_1970_2000_plot + theme(legend.position = "bottom"), 
                    funda_altman_2001_2019_plot + theme(legend.position = "bottom"), 
                    ncol = 2, nrow = 1), ncol = 1, nrow = 2)
```

\newpage
# Fundamental variable weighted portfolio returns and VWRETD yearly returns, non-compounded 
```{r fig.width=12, fig.height=3.5, warning=FALSE}
funda_1970_2019_plot2 + theme(legend.position = "bottom")
```

* On the non-compounded fundamental variable portfolio returns, we can see the drop in returns because of the 1973-1975 recession. During this period of time there are also NBER based Recession indicators. We can also see dips in the yearly returns in the early 1980s and around 1982, both of which are times where the NBER recession indicator is active. Then, in early 1990, we again see the yearly returns crash coinciding with the NBER recession indicator. These are not visible on the compounded returns graph because of the scale.

* The dotcom bubble around the year 2000 is the first major movement that can be seen in both the compounded portfolio returns and the non-compounded returns. The great recession from 2008-2009 also can be seen in both graphs, and additionally matches the NBER recession indicator.


# Descriptive stats and ratios for portfolio returns
```{r out.width=12}
knitr::kable(funda_stats, digits = 3) %>%
  kable_styling(font_size = 8)
```

\newpage
# Excess returns compounded compared with MKT, SMB, HML
```{r fig.width=12, fig.height=3.5, warning=FALSE}
funda_excess_ports_compound_plot + theme(legend.position = "bottom")
```

### Altman-Z score portfolio again was a significant outlier, so it is plotted separately
```{r fig.width=12, fig.height=3.5, warning=FALSE}
funda_compound_altman + theme(legend.position = "bottom")
```

\newpage
# Excess returns yearly compared with MKT, SMB, HML
```{r fig.width=12, fig.height = 3.5, warning=FALSE}
funda_excess_ports_yearly_plot + theme(legend.position = "bottom")
```

* The excess returns of the fundamental variable weighted portfolios are all larger than those of MKT, SMB, and HML. Most of them were within a similar scale, but the returns from the asset turnover portfolio, trailing 5-year profitability, and Altman-Z portfolios were all significantly larger.

* There could be significant survivorship bias in the constructed portfolios. Because each year has been filtered to only use stocks with a large market cap and minimum price, a lot of the stocks ending up in the portfolio are time-tested and historically proven to be profitable, as they have the large market cap in the first place. The portfolio restrictions can also help avoid larger losses. If a stock has multiple bad years in a row, losses will be cut when the stock market capitalization drops below our minimum and the stock is no longer in the portfolio.

* The fundamental indexing does look to be better than the market in all cases though. Some of the fundamental variable indexes look to be able to better hedge against risks as well.

* The sharpe ratios of all the portfolios are extremely high. The fundamental variable weighting must help in mitigating investments in riskier firms. A few of the information ratios are very strong (book value, trailing 5 year cash flow, and Altman-Z portfolios), but these are definitely relatively more normal than the high sharpe ratios. 

* The volatility in most of the portfolios is low, but some notable standouts are the Altman-Z portfolio and profitability portfolio. A lot of the trailing values have negative skewness which is faily interesting. The Altman-Z portfolio also has a very strong positive skew and kurtosis. There were quite a few very outlier strong yearly returns in the altman-Z portfolio, leading to its crazy returns. 

\newpage
# Market variable-weighted potfolio and VWRETD compounded returns
```{r fig.width=18, fig.height=9, warning=FALSE}
# for knitr output
ggarrange(market_var_1970_2019_plot + theme(legend.position = "bottom"), 
          ggarrange(market_var_1970_2000_plot + theme(legend.position = "bottom"), 
                    market_var_2001_2019_plot + theme(legend.position = "bottom"), 
                    ncol = 2, nrow = 1), ncol = 1, nrow = 2)
```


# Market variable-weighted portfolio returns and VWRETD yearly returns, non-compounded 
```{r fig.width=12, fig.height=3.5, warning=FALSE}
market_1970_2019_plot2 + theme(legend.position = "bottom")
```

* Similar to the fundamental variable weighted portfolio returns, looking at the yearly, non-compounded returns, we can see the drop in returns because of the 1973-1975 recession as well as dips in the returns of the early 1980s and around 1982, both of which are times where the NBER recession indicator is active. Then, in early 1990s, we again see the yearly returns crash coinciding with the NBER recession indicator. These are not visible on the compounded returns graph because of the scale. 

* Since the market variable weighted portfolio returns look to be much larger than those from the fundamental variable weighted porfolio, he dotcom bubble around the year 2000 can be only seen in both the yearly, non-compounded portfolio returns and the non-compounded returns. Then, the great recession from 2008-2009 can be seen in both graphs.

# Descriptive stats and ratios for market variable weighted portfolio returns
```{r out.width=12}
knitr::kable(market_stats, digits = 3) %>%
  kable_styling(font_size = 8)
```

## Excess returns compounded compared with MKT, SMB, HML
```{r fig.width=12, fig.height=3}
market_excess_ports_compound_plot + theme(legend.position = "bottom")
```

## Excess returns yearly compared with MKT, SMB, HML
```{r fig.width=12, fig.height=3}
market_excess_ports_yearly_plot + theme(legend.position = "bottom")
```

* Like the portfolio returns, the excess returns of the fundamental variable weighted portfolios are all very large, performing significantly better than the MKT, SMB, and HML returns. The total volatility assuming zero average portfolio was very strong. 

* There is probably also significant survivorship bias in this fundamental variable weighted portfolio as well.

* The sharpe ratios of all the portfolios are very strong, but also very consistent, with all of them a little greater than 3. This is different from the fundamental variable portfolio, as that has some very strong outliers. The information ratios are also more consistent and steady. 

* Most of other descriptive stats for the market variable portfolio are similar. This could possible be due to all of them being regression based and using overlapping values. I think the returns would be highly correlated as well. 

* These are much higher volatility than the fundamental variable portfolios which could explain the lower sharpe and information ratios. All are positively skewed with strong kurtosis as well.

